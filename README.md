# Experiment with Appium for Android.

***Во всем ниже описанном я предполагаю, что у читателя PC с Windows.
Настройка окружения
Скачиваем и устанавливаем JDK
Переходим на сайт Oracle http://www.oracle.com и ищем Java SE Development Kit 8 Downloads (в данный момент актуальна ссылка http://www.oracle.com/technetwork/java/javase/downloads/2133151).
Скачиваем последнюю стабильную версию Java SE Development Kit (в данный момент 8u91) под свою платформу (скорее всего это Windows x64).
Устанавливаем JDK, можно не изменять настройки и оставить их по умолчанию.
Устанавливаем переменную окружения JAVA_HOME: в Windows кликаем правой кнопкой мыши на "Мой компьютер" -> Свойства -> Дополнительные параметры системы -> Переменные среды ... -> Системные переменные и добавляем JAVA_HOME, указав нужный путь (выглядит примерно так C:\Program Files\Java\jdk1.8.0_77).
Устанавливаем переменную окружения Path: в переменной Path добавляем к списку директорий строку (должна выглядеть примерно так C:\Program Files\Java\jdk1.8.0_77\bin - номер версии в названии может отличаться).
Проверяем корректность установки, набрав в командной строке* (Пуск -> cmd) java -version (здесь и далее БЕЗ кавычек!).
Результат должен быть примерно таким:
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
*Если командная строка была уже открыта ДО изменений в переменной Path – нужно перезапустить командную строку!
 
Скачиваем и устанавливаем Maven
Заходим на сайт Maven http://maven.apache.org/download.cgi в раздел Download и скачиваем последнюю стабильную версию (подойдет Binary zip archive).
Распаковываем архив в инсталляционную директорию, например, в C:\Program Files\maven
Устанавливаем переменную окружения M2_HOME: в Windows кликаем правой кнопкой мыши на "Мой компьютер" -> Свойства -> Дополнительные параметры системы -> Переменные среды ... -> Cистемные переменные и добавляем M2_HOME, указав нужный путь (например, C:\Program Files\maven\).
Устанавливаем переменную окружения Path: в переменной Path добавляем к списку директорий строку C:\Program Files\maven\bin (в Вашем случае может отличаться).
Проверяем корректность установки, набрав в командной строке (Пуск -> cmd) mvn -version.
Результат должен быть примерно таким:
Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T19:41:47+03:00)
Maven home: C:\Program Files\apache-maven-3.3.9
Java version: 1.7.0_79, vendor: Oracle Corporation
Java home: C:\Program Files\Java\jdk1.7.0_79\jre
Default locale: ru_RU, platform encoding: Cp1251
OS name: "windows 7", version: "6.1", arch: "amd64", family: "windows"
 
Скачиваем и устанавливаем Android SDK
https://developer.android.com/studio/index.html спускаемся к заголовку Get just the command line tools и скачиваем последнюю версию (сейчас это, например, installer_r24.4.1-windows.exe ). Лучше устанавливать НЕ в Program Files, а в корень диска C:\ или в C:\Android.
 
Выкачиваем необходимые компоненты Android SDK
Запускаем SDK Manager (C:\Android\android-sdk\Manager.exe). Нажимаем Deselect All и выбираем Android SDK Tools, Android SDK Platform-tools и Android SDK Build-tools; Android 4.4.2 (API19): Intel x86 Atom System Image, SDK Platform; Extras: Intel x86 Emulator Accelerator (HAXM installer). Нажимаем Install packages..., принимаем лицензионные соглашения, устанавливаем.
 
Устанавливаем Intel HAXM
Переходим к C:\Android\android-sdk\extras\intel\Hardware_Accelerated_Execution_Manager и запускаем инсталлятор (intelhaxm-android.exe)*. Можно не изменять настройки и оставить все по умолчанию.
*Дистрибутив Intel HAXM не обязательно выкачивать при помощи Android SDK Manager (как описано в предыдущем пункте), а можно скачать и традиционным способом с официального сайта Intel.
 
Скачиваем у устанавливаем IntelliJ IDEA
Переходим по ссылке https://www.jetbrains.com/idea/#chooseYourEdition и выбираем Community Edition. При установке можно не изменять настройки и оставить все по умолчанию.
 
Скачиваем и устанавливаем Appium
Переходим по ссылке http://appium.io/ и кликаем по кнопке в центре экрана Download Appium. Распаковываем архив, инсталлим*, при установке можно не изменять настройки и оставить все по умолчанию.
*Для работы Appium необходим .NET Framework 4.5 — скорее всего уже есть на машине.
 
Импорт проекта и запуск тестов
 
Скачиваем или форкаем (кому как удобнее) репозиторий в удобную для работы папку https://github.com/chibert/DrWeb_Appium_Android
Дистрибутив приложения для автотестов
Скачиваем себе на комп нужный дистрибутив (какой именно подойдет и откуда его взять сейчас — спросить у разработчиков)! Разместить его лучше в области, куда есть доступ без прав администратора, например в Загрузках (т. е. в моем случае выглядит так: C:\Users\o.polyakov.DRWEB\Downloads\drweb-11.0.0-ss-nolicense-android.apk)
IntelliJ IDEA
1. Запускаем IntelliJ IDEA.

Выбираем пункт Import Project.
2. Ищем путь к папке со скаченным проектом (см. первый пункт).

Выбираем нужную папку и нажимаем "OK".
3. Выбираем Import project from external model и Maven. Жмем "Next".

4. Можно ничего не менять. Жмем "Next".

5. Можно ничего не менять. Жмем "Next".

6. Выбираем Java SDK 1.8 (при необходимости указываем к ней путь — будет примерно таким: C:\Program Files\Java\jdk1.8.0_77\). Жмем "Next".

7. При желании можно изменить название проекта. Жмем "Finish".

 
8. В итоге увидим что-то похожее на:

Развернув все необходимые модули и пакеты увидим примерно следующее:

 
9. Открываем для редактирования MobileDriverRule (находится в пакете "rules" модуля "steps-module").

Редактируем строку
desiredCapabilities.setCapability("app", "C:\\Users\\o.polyakov.DRWEB\\Downloads\\drweb-11.0.0-ss-nolicense-android.apk");
вписав свой путь к приложению.
 
Подсоединяем к компу шнурком тестируемый девайс (или запускаем виртуалку)
 
Appium
1. Запускаем Appium.

2. Кликаем по кнопке с роботом и вписываем:
- путь к дистрибутиву приложения для тестирования;
- имя устройства (вводим любой текст, например, "12345");
- путь к Android SDK.

3. *Не обязательно* Кликаем по кнопке с человеком и вписываем в поле Custom Server Flags:
--command-timeout "20000"

4. Кликаем по кнопке «плей».

Appium запущен.
 
Запуск теста
В IntelliJ IDEA кликаем правой кнопкой мыши по одному из тестов в пакете ru.qatools.school.mobiletests модуля commons-module и выбираем пункт Run (с зеленой кнопкой "плей").
Ждем...
Тест запустился — пошла движуха на дейвайсе и в логах Аппиума.
 
Что где находится в проекте и что с этим всем дальше делать
 
В 2х словах о «проекте» 
По сути, при данном подходе мы представляем активити приложения Android в виде страниц web-браузера и работаем с ними при помощи WebDriver (имея возможность использовать все подходы, библиотеки и прочие прелести, наработанные за годы огромным сообществом web-авто-тетстеров). В наших тестах мы уже не напрямую работаем с UIAutomator (как в параллельном проекте с тестами URL-фильтра для различных браузеров), а через посредника - Appium. Данные тесты могут стать при необходимости мультиплатформенными (если бы у нас был идентичный дизайн приложения для iOS) + писать тесты можно не только на Java (но ведь любим именно Джаву, правда же?.. =))
 
Структура «проекта»
Логика разделена на 4 составляющие:
1) Настройки драйвера (class MobileDriverRule) — пакет ru.qatools.school.rules модуля steps-module.
2) Описание экранов приложения (объектов для взаимодействия на них) — ru.qatools.school.drwebscreens модуля steps-module.
3) Стандартные действия над элементами интерфейса (class DefaultSteps) — пакет ru.qatools.school.steps.mobilesteps модуля steps-module.
4) Сами тесты, основанные на стандартных шагах, которые применяются к элементам экрана — пакет ru.qatools.school.mobiletests модуля commons-module.
 
Куда двигаться дальше и почему все так жалко выглядит
По хорошему, в данном проекте нужно организовать использование java-client https://github.com/appium/java-client и представлять наши объекты на страницах как AndroidElement или MobileElement, но автор этих строк, к привиликому своему стыду и сожалению, пока до этого не дошел — я не волшебник, я только учусь... Но (!) за то Вам (или тебе), читатель, теперь ясно куда двигаться (наверное... ,-)).
 
Как это работает и при чем тут магия
 
Что нужно для понимания происходящего: минимальные представления о синтаксисе Java. Если их нет, а джавадоки и джавакниги не вызывают энтузиазма, то стоит зайти сюда http://javarush.ru/ и пройти несколько уровней (хотя бы 7-8, первые 10 совершенно бесплатны) - не сильно академично, но практично.
 
Настройка драйвера
Лично для меня это магия (что напрямую говорит о моем "высоком" IQ). Один раз показали как это должно выглядеть (и примерно та же настройка расписана в доках к Аппиуму). Видны закомментированные, но не удаленные строки:
//desiredCapabilities.setCapability("app", "http://autoschool.github.io/files/ya-metro.apk");
//desiredCapabilities.setCapability("appWaitActivity", "ru.yandex.metro.MainActivity");
Они не обязательны и наши тесты работают без них, но в проекте, на базе которого «сделан» этот они использовались (ну, тут уже всем понятно откуда ноги растут, да и скрывать нет особых причин).
 
Стандартные шаги
Это магия библиотек, которые используются (и еще будут подключаться - потому очень нужно разобраться в доках к java-client для Appium).
 
Описание экранов
Термин какой-то не очень красивый, но вот придумать лучше не получается, так как у нас есть экраны приложения, мы их как-то условно разделили и описываем как искать на них элементы. По синтаксису, я так думаю, более-менее все ясно, но чуть-чуть поясню на примере одной записи для главного активити приложения (class MainScreen в пакете ru.qatools.school.drwebscreens модуля steps-module):
@Name("Scaner")
@FindBy(id = "component_scaner")
private HtmlElement scaner;
 
public HtmlElement getScaner() {
return scaner;
}
 
@Name("Scaner") — на этом не будем останавливаться, нужно для отчетов типа Allure, которые сейчас не подключены (см. https://github.com/allure-framework) + для нашего собственного удобства, так как заодно на великом и могучем понятно описывают, что именно мы тут пытаемся найти.
@FindBy(id = "component_scaner") — как ищем — в данном случае по id (можно еще искать по className, linkText и многим другим вещам). Лучше всего по id, если его нет, то по className.
Откуда брать все эти тэги? В этом поможет нам стандартная утилита, входящая в комплект поставки Android SDK "uiautomatorviewer" (C:\Android\android-sdk\tools\uiautomatorviewer.bat). Подключаем девайс (или виртуалку) с нужным экраном и нажимаем на кнопочку . Дальше все станет ясно.
private HtmlElement scaner; - как обзываем то, что нашли (scaner типа HtmlElement с модификатором доступа private).
public HtmlElement getScaner() { return scaner; } - все это публичный геттер, при помощи которого мы будем обращаться к данному объекту при написании самих тестов.
 
Встречаются конструкции чуть посложнее, где нужно понимать, что такое в java коллекции List, но это все тоже очень просто, вот пример с котиками http://developer.alexanderklimov.ru/android/java/arraylist.php
 
Сами тесты
В целом синтаксис jUnit (видим @Before, @Test, @Rule...). Если не знакомы, стоит прочитать любую коротенькую статью.
В 2х словах: описанное в @Before будет осуществляться перед каждым тестом, которые разделены @Test (при каждом новом тесте Аппиум очистит данные приложения и начнет с чистого листа, во всяком случае сейчас это происходит именно так).
 
2 слова о синтаксисе самих тестов, на примере
defaultSteps.clickOn(onLicensScreen().getStatisticCheckbox());
Из класса "Стандартных шагов" применяем действие "Кликнуть по" на экране "Лицензионного соглашения" по объекту "Чекбокс сбора Статистики". Думаю, что тут как раз все понятно, так как реально не сложно и даже присутствует общечеловеческая логика.
